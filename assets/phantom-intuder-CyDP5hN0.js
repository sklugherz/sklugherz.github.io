import{_ as t,c as a}from"./index-C0MDTiFO.js";const o="/assets/initial-open-TioRAsK5.png",n="/assets/base64-BDh0cbQU.png",s="/assets/good-data-6TkyxNsr.png",i="/assets/bad-data-DkbOAm6-.png",c="/assets/breakpoint-ByPAfDC9.png",d="/assets/filtered-results-DXfz9y3m.png",r="/assets/Completed-Challenge-Rdc3Xfg3.png",p={};function h(l,e){return e[0]||(e[0]=a('<h2 data-v-ce986026>Ph4nt0m 1ntrud3r Challenge <br data-v-ce986026> PicoCTF 2025</h2><p data-v-ce986026>Welcome to my walkthrough for PicoCTF&#39;s Ph4nt0m 1ntrud3r challenge.</p><p data-v-ce986026> Lets take a look at the instructions. They require us to download a pcap file and asks us to analyze the traffic and apply the right filters to uncover the threat actors malicious activity. </p><p data-v-ce986026> Using wireshark, or your preffered packet analysis tool, we can open the file and examine its contents. </p><img src="'+o+'" alt="Photo of the challenge instructions" data-v-ce986026><p data-v-ce986026> Wireshark seems to have identified the majority of them as retransmissions, likely a form of packet flooding attempt. </p><p data-v-ce986026> Taking a look at the information section we can see that the tcp connections are SYN only instead of the usual SYN, ACK, SYN/ACK handshake of a normal TCP connection. </p><p data-v-ce986026> This behavior is typical of a SYN Flood. Typically a SYN Flood is used in the reconnisaince faze of an attack to map out the network with a tool such as NMAP. </p><p data-v-ce986026> Now that we&#39;ve identified the type of attack the threat actor conducted lets take a look into the data of first tcp connection. </p><p data-v-ce986026> Taking a look at the segment data we can notice a familiar pattern: </p><img src="'+n+'" alt="Image of Base64 Encoding" data-v-ce986026><p data-v-ce986026> This pattern is typically base64 encoded data. Right-clicking the data to copy it into ASCII, we can use a tool like CyberChef and decode the data. </p><img src="'+s+'" alt="Image of decoded Base64 data" class="placeholder" data-v-ce986026><h5 data-v-ce986026> Note: You may have to remove some of the packet headers after copying it into CyberChef. </h5><p data-v-ce986026> This looks like the begginning format of a flag. Interestingly enough the orginial tcp connection was not the first connection captured. </p><p data-v-ce986026> Filtering the packets by time and trying to decode the data of the first packet, we get gibberish. </p><img src="'+i+'" alt="Image of non-Base64 decoded data" class="placeholder" data-v-ce986026><p data-v-ce986026> We need to filter out the bad packets. </p><p data-v-ce986026> Looking at the differences in information between the original packet we looked at, packet NO. 1, and the bad packet we looked at, we can see a difference in tcp data length. </p><img src="'+c+'" alt="Image of breakpoint between difference packet information lengths" data-v-ce986026><p class="short" data-v-ce986026> Filtering out bad packets with the length of 8: </p><img src="'+d+'" alt="Image of filtered results" data-v-ce986026><p data-v-ce986026> Examining the data from these filtered packets we can see they seem to be in the base64 format. Decoding all the packet data with CyberChef gives us our flag to complete the challenge. </p><img src="'+r+'" alt="Image of decoded flag" data-v-ce986026>',24))}const g=t(p,[["render",h],["__scopeId","data-v-ce986026"]]);export{g as default};
